// Copyright (c) 2018 The ExchangeCoin team
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package cequihash

import (
	"encoding/binary"
	"testing"
)

type solverTest struct {
	n           int
	k           int
	I           []byte
	nonce       uint32
	algoVersion uint8
	solutions   [][]uint32
}

type validatorTest struct {
	n           int
	k           int
	valid       bool
	I           []byte
	nonce       uint32
	algoVersion uint8
	solution    []uint32
}

type equihash1445TestCase struct {
	valid       bool
	header      []byte
	solution    []byte
	nonce       uint32
	algoVersion uint8
}

var solverTests = []solverTest{
	//--------------------------------------------------------------------------
	// Test data for equihash 96,5
	//--------------------------------------------------------------------------
	{96, 5, []byte("block header"), 0, 0, [][]uint32{
		{1008, 18280, 34711, 57439, 3903, 104059, 81195, 95931, 58336, 118687, 67931, 123026, 64235, 95595, 84355, 122946, 8131, 88988, 45130, 58986, 59899, 78278, 94769, 118158, 25569, 106598, 44224, 96285, 54009, 67246, 85039, 127667},
		{976, 126621, 100174, 123328, 38477, 105390, 38834, 90500, 6411, 116489, 51107, 129167, 25557, 92292, 38525, 56514, 1110, 98024, 15426, 74455, 3185, 84007, 24328, 36473, 17427, 129451, 27556, 119967, 31704, 62448, 110460, 117894},
		{3976, 108868, 80426, 109742, 33354, 55962, 68338, 80112, 26648, 28006, 64679, 130709, 41182, 126811, 56563, 129040, 4013, 80357, 38063, 91241, 30768, 72264, 97338, 124455, 5607, 36901, 67672, 87377, 17841, 66985, 77087, 85291},
		{5970, 21862, 34861, 102517, 11849, 104563, 91620, 110653, 7619, 52100, 21162, 112513, 74964, 79553, 105558, 127256, 21905, 112672, 81803, 92086, 43695, 97911, 66587, 104119, 29017, 61613, 97690, 106345, 47428, 98460, 53655, 109002},
		{1278, 107636, 80519, 127719, 19716, 130440, 83752, 121810, 15337, 106305, 96940, 117036, 46903, 101115, 82294, 118709, 4915, 70826, 40826, 79883, 37902, 95324, 101092, 112254, 15536, 68760, 68493, 125640, 67620, 108562, 68035, 93430},
	}},
	{96, 5, []byte("block header"), 1, 0, [][]uint32{
		{1911, 96020, 94086, 96830, 7895, 51522, 56142, 62444, 15441, 100732, 48983, 64776, 27781, 85932, 101138, 114362, 4497, 14199, 36249, 41817, 23995, 93888, 35798, 96337, 5530, 82377, 66438, 85247, 39332, 78978, 83015, 123505},
	}},
	{96, 5, []byte("block header"), 2, 0, [][]uint32{
		{165, 27290, 87424, 123403, 5344, 35125, 49154, 108221, 8882, 90328, 77359, 92348, 54692, 81690, 115200, 121929, 18968, 122421, 32882, 128517, 56629, 88083, 88022, 102461, 35665, 62833, 95988, 114502, 39965, 119818, 45010, 94889},
	}},
	{96, 5, []byte("block header"), 10, 0, [][]uint32{
		{1855, 37525, 81472, 112062, 11831, 38873, 45382, 82417, 11571, 47965, 71385, 119369, 13049, 64810, 26995, 34659, 6423, 67533, 88972, 105540, 30672, 80244, 39493, 94598, 17858, 78496, 35376, 118645, 50186, 51838, 70421, 103703},
		{3671, 125813, 31502, 78587, 25500, 83138, 74685, 98796, 8873, 119842, 21142, 55332, 25571, 122204, 31433, 80719, 3955, 49477, 4225, 129562, 11837, 21530, 75841, 120644, 4653, 101217, 19230, 113175, 16322, 24384, 21271, 96965},
	}},
	{96, 5, []byte("block header"), 11, 0, [][]uint32{
		{2570, 20946, 61727, 130667, 16426, 62291, 107177, 112384, 18464, 125099, 120313, 127545, 35035, 73082, 118591, 120800, 13800, 32837, 23607, 86516, 17339, 114578, 22053, 85510, 14913, 42826, 25168, 121262, 33673, 114773, 77592, 83471},
	}},
	{96, 5, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 0, 0, [][]uint32{
		{3130, 83179, 30454, 107686, 71240, 88412, 109700, 114639, 10024, 32706, 38019, 113013, 18399, 92942, 21094, 112263, 4146, 30807, 10631, 73192, 22216, 90216, 45581, 125042, 11256, 119455, 93603, 110112, 59851, 91545, 97403, 111102},
		{3822, 35317, 47508, 119823, 37652, 117039, 69087, 72058, 13147, 111794, 65435, 124256, 22247, 66272, 30298, 108956, 13157, 109175, 37574, 50978, 31258, 91519, 52568, 107874, 14999, 103687, 27027, 109468, 36918, 109660, 42196, 100424},
	}},
	{96, 5, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 1, 0, [][]uint32{
		{2261, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026, 15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 69567, 114474, 104973, 122568},
		{16700, 46276, 21232, 43153, 22398, 58511, 47922, 71816, 23370, 26222, 39248, 40137, 65375, 85794, 69749, 73259, 23599, 72821, 42250, 52383, 35267, 75893, 52152, 57181, 27137, 101117, 45804, 92838, 29548, 29574, 37737, 113624},
	}},
	{96, 5, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 2, 0, [][]uint32{
		{6005, 59843, 55560, 70361, 39140, 77856, 44238, 57702, 32125, 121969, 108032, 116542, 37925, 75404, 48671, 111682, 6937, 93582, 53272, 77545, 13715, 40867, 73187, 77853, 7348, 70313, 24935, 24978, 25967, 41062, 58694, 110036},
	}},
	{96, 5, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 10, 0, [][]uint32{
		{15465, 59017, 93851, 112478, 24940, 128791, 26154, 107289, 24050, 78626, 51948, 111573, 35117, 113754, 36317, 67606, 21508, 91486, 28293, 126983, 23989, 39722, 60567, 97243, 26720, 56243, 60444, 107530, 40329, 56467, 91943, 93737},
		{968, 90691, 70664, 112581, 17233, 79239, 66772, 92199, 27801, 44198, 58712, 122292, 28227, 126747, 70925, 118108, 2876, 76082, 39335, 113764, 26643, 60579, 50853, 70300, 19640, 31848, 28672, 87870, 33574, 50308, 40291, 61593},
		{2229, 30387, 14573, 115700, 20018, 124283, 84929, 91944, 26341, 64220, 69433, 82466, 29778, 101161, 59334, 79798, 2533, 104985, 50731, 111094, 10619, 80909, 15555, 119911, 29028, 42966, 51958, 86784, 34561, 97709, 77126, 127250},
		{1181, 61261, 75793, 96302, 36209, 113590, 79236, 108781, 8275, 106510, 11877, 74550, 45593, 80595, 71247, 95783, 2991, 99117, 56413, 71287, 10235, 68286, 22016, 104685, 51588, 53344, 56822, 63386, 63527, 75772, 93100, 108542},
	}},
	{96, 5, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 11, 0, [][]uint32{
		{1120, 77433, 58243, 76860, 11411, 96068, 13150, 35878, 15049, 88928, 20101, 104706, 29215, 73328, 39498, 83529, 9233, 124174, 66731, 97423, 10823, 92444, 25647, 127742, 12207, 46292, 22018, 120758, 14411, 46485, 21828, 57591},
	}},
	{96, 5, []byte("Test case with 3+-way collision in the final round."), 0x00000000000000000000000000000000000000000000000000000000000007f0, 0, [][]uint32{
		{2321, 121781, 36792, 51959, 21685, 67596, 27992, 59307, 13462, 118550, 37537, 55849, 48994, 78703, 58515, 100100, 11189, 98120, 45242, 116128, 33260, 47351, 61550, 116649, 11927, 20590, 35907, 107966, 28779, 57407, 54793, 104108},
		{2321, 121781, 36792, 51959, 21685, 67596, 27992, 59307, 13462, 118550, 37537, 55849, 48994, 58515, 78703, 100100, 11189, 98120, 45242, 116128, 33260, 47351, 61550, 116649, 11927, 20590, 35907, 107966, 28779, 57407, 54793, 104108},
		{2321, 121781, 36792, 51959, 21685, 67596, 27992, 59307, 13462, 118550, 37537, 55849, 48994, 100100, 58515, 78703, 11189, 98120, 45242, 116128, 33260, 47351, 61550, 116649, 11927, 20590, 35907, 107966, 28779, 57407, 54793, 104108},
		{1162, 129543, 57488, 82745, 18311, 115612, 20603, 112899, 5635, 103373, 101651, 125986, 52160, 70847, 65152, 101720, 5810, 43165, 64589, 105333, 11347, 63836, 55495, 96392, 40767, 81019, 53976, 94184, 41650, 114374, 45109, 57038},
		{8144, 33053, 33933, 77498, 21356, 110495, 42805, 116575, 27360, 48574, 100682, 102629, 50754, 64608, 96899, 120978, 11924, 74422, 49240, 106822, 12787, 68290, 44314, 50005, 38056, 49716, 83299, 95307, 41798, 82309, 94504, 96161},
		{4488, 83544, 24912, 62564, 43206, 62790, 68462, 125162, 6805, 8886, 46937, 54588, 15509, 126232, 19426, 27845, 5959, 56839, 38806, 102580, 11255, 63258, 23442, 39750, 13022, 22271, 24110, 52077, 17422, 124996, 35725, 101509},
	}},

	//--------------------------------------------------------------------------
	// Test data for equihash 144,5
	//--------------------------------------------------------------------------
	// Commented out for now in order to reduce test time
	// {144, 5, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 0, [][]uint32{
	// 	{3941315, 24094495, 6239252, 31147877, 4539968, 10073200, 19373368, 21437421, 12010666, 17927816, 20276487, 27935905, 13784035, 22628361, 14361186, 32553544, 5217720, 33501525, 5827180, 13523151, 13553395, 20296045, 17491048, 31386457, 7422127, 22349209, 10575213, 24308584, 8792931, 13557014, 25874493, 31279313},
	// }},
}

var validatorTests = []validatorTest{
	//--------------------------------------------------------------------------
	// Test data for equihash 96,5
	//--------------------------------------------------------------------------
	// Original valid solution
	{96, 5, true, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 1, 0,
		[]uint32{2261, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026, 15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 69567, 114474, 104973, 122568},
	},
	// Change one index
	{96, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 1, 0,
		[]uint32{2262, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026, 15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 69567, 114474, 104973, 122568},
	},
	// Swap two arbitrary indices
	{96, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 1, 0,
		[]uint32{45858, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 2261, 116805, 92842, 111026, 15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 69567, 114474, 104973, 122568},
	},
	// Reverse the first pair of indices
	{96, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 1, 0,
		[]uint32{15185, 2261, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026, 15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 69567, 114474, 104973, 122568},
	},
	// Swap the first and second pairs of indices
	{96, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 1, 0,
		[]uint32{36112, 104243, 2261, 15185, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026, 15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 69567, 114474, 104973, 122568},
	},
	// Swap the second-to-last and last pairs of indices
	{96, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 1, 0,
		[]uint32{2261, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026, 15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 104973, 122568, 69567, 114474},
	},
	// Swap the first half and second half
	{96, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 1, 0,
		[]uint32{15972, 115059, 85191, 90330, 68190, 122819, 81830, 91132, 23460, 49807, 52426, 80391, 69567, 114474, 104973, 122568, 2261, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026},
	},
	// Sort the indices
	{96, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 1, 0,
		[]uint32{2261, 15185, 15972, 23460, 23779, 32642, 36112, 45858, 49807, 52426, 68190, 69567, 69878, 76925, 80080, 80391, 81830, 85191, 90330, 91132, 92842, 104243, 104973, 111026, 114474, 115059, 116805, 118332, 118390, 122568, 122819, 130041},
	},
	// Duplicate indices
	{96, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 1, 0,
		[]uint32{2261, 2261, 15185, 15185, 36112, 36112, 104243, 104243, 23779, 23779, 118390, 118390, 118332, 118332, 130041, 130041, 32642, 32642, 69878, 69878, 76925, 76925, 80080, 80080, 45858, 45858, 116805, 116805, 92842, 92842, 111026, 111026},
	},
	// Duplicate first half
	{96, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 1, 0,
		[]uint32{2261, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026, 2261, 15185, 36112, 104243, 23779, 118390, 118332, 130041, 32642, 69878, 76925, 80080, 45858, 116805, 92842, 111026},
	},
	//--------------------------------------------------------------------------
	// Test data for equihash 144,5
	//--------------------------------------------------------------------------
	// Original valid solution
	{144, 5, true, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 0, 0,
		[]uint32{3941315, 24094495, 6239252, 31147877, 4539968, 10073200, 19373368, 21437421, 12010666, 17927816, 20276487, 27935905, 13784035, 22628361, 14361186, 32553544, 5217720, 33501525, 5827180, 13523151, 13553395, 20296045, 17491048, 31386457, 7422127, 22349209, 10575213, 24308584, 8792931, 13557014, 25874493, 31279313},
	},
	// Change one index
	{144, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 0, 0,
		[]uint32{3941316, 24094495, 6239252, 31147877, 4539968, 10073200, 19373368, 21437421, 12010666, 17927816, 20276487, 27935905, 13784035, 22628361, 14361186, 32553544, 5217720, 33501525, 5827180, 13523151, 13553395, 20296045, 17491048, 31386457, 7422127, 22349209, 10575213, 24308584, 8792931, 13557014, 25874493, 31279313},
	},
	// Swap two arbitrary indices
	{144, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 0, 0,
		[]uint32{12010666, 24094495, 6239252, 31147877, 4539968, 10073200, 19373368, 21437421, 3941315, 17927816, 20276487, 27935905, 13784035, 22628361, 14361186, 32553544, 5217720, 33501525, 5827180, 13523151, 13553395, 20296045, 17491048, 31386457, 7422127, 22349209, 10575213, 24308584, 8792931, 13557014, 25874493, 31279313},
	},
	// Reverse the first pair of indices
	{144, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 0, 0,
		[]uint32{24094495, 3941315, 6239252, 31147877, 4539968, 10073200, 19373368, 21437421, 12010666, 17927816, 20276487, 27935905, 13784035, 22628361, 14361186, 32553544, 5217720, 33501525, 5827180, 13523151, 13553395, 20296045, 17491048, 31386457, 7422127, 22349209, 10575213, 24308584, 8792931, 13557014, 25874493, 31279313},
	},
	// Swap the first and second pairs of indices
	{144, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 0, 0,
		[]uint32{6239252, 31147877, 3941315, 24094495, 4539968, 10073200, 19373368, 21437421, 12010666, 17927816, 20276487, 27935905, 13784035, 22628361, 14361186, 32553544, 5217720, 33501525, 5827180, 13523151, 13553395, 20296045, 17491048, 31386457, 7422127, 22349209, 10575213, 24308584, 8792931, 13557014, 25874493, 31279313},
	},
	// Swap the second-to-last and last pairs of indices
	{144, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 0, 0,
		[]uint32{3941315, 24094495, 6239252, 31147877, 4539968, 10073200, 19373368, 21437421, 12010666, 17927816, 20276487, 27935905, 13784035, 22628361, 14361186, 32553544, 5217720, 33501525, 5827180, 13523151, 13553395, 20296045, 17491048, 31386457, 7422127, 22349209, 10575213, 24308584, 25874493, 31279313, 8792931, 13557014},
	},
	// Swap the first half and second half
	{144, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 0, 0,
		[]uint32{5217720, 33501525, 5827180, 13523151, 13553395, 20296045, 17491048, 31386457, 7422127, 22349209, 10575213, 24308584, 8792931, 13557014, 25874493, 31279313, 3941315, 24094495, 6239252, 31147877, 4539968, 10073200, 19373368, 21437421, 12010666, 17927816, 20276487, 27935905, 13784035, 22628361, 14361186, 32553544},
	},
	// Sort the indices
	{144, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 0, 0,
		[]uint32{3941315, 4539968, 5217720, 5827180, 6239252, 7422127, 8792931, 10073200, 10575213, 12010666, 13523151, 13553395, 13557014, 13784035, 14361186, 17491048, 17927816, 19373368, 20276487, 20296045, 21437421, 22349209, 22628361, 24094495, 24308584, 25874493, 27935905, 31147877, 31279313, 31386457, 32553544, 33501525},
	},
	// Duplicate indices
	{144, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 0, 0,
		[]uint32{3941315, 3941315, 24094495, 24094495, 6239252, 6239252, 31147877, 31147877, 4539968, 4539968, 10073200, 10073200, 19373368, 19373368, 21437421, 21437421, 12010666, 12010666, 17927816, 17927816, 20276487, 20276487, 27935905, 27935905, 13784035, 13784035, 22628361, 22628361, 14361186, 14361186, 32553544, 32553544},
	},
	// Duplicate first half
	{144, 5, false, []byte("Equihash is an asymmetric PoW based on the Generalised Birthday problem."), 0, 0,
		[]uint32{3941315, 24094495, 6239252, 31147877, 4539968, 10073200, 19373368, 21437421, 12010666, 17927816, 20276487, 27935905, 13784035, 22628361, 14361186, 32553544, 3941315, 24094495, 6239252, 31147877, 4539968, 10073200, 19373368, 21437421, 12010666, 17927816, 20276487, 27935905, 13784035, 22628361, 14361186, 32553544},
	},
}

var equihash1445TestCases = []equihash1445TestCase{
	// Positive cases
	{
		true, []byte{
			6, 0, 0, 0, // Header.Version
			248, 93, 233, 12, 17, 212, 94, 177, // Header.PrevBlock chainhash.Hash (32bytes)
			53, 152, 220, 165, 143, 204, 86, 16,
			181, 70, 109, 99, 248, 26, 218, 254,
			114, 153, 31, 82, 76, 1, 83, 12,
			38, 95, 7, 145, 250, 44, 210, 131, // Header.MerkleRoot chainhash.Hash (32bytes)
			159, 43, 224, 21, 21, 114, 217, 232,
			46, 246, 46, 100, 115, 7, 121, 121,
			72, 141, 39, 148, 161, 50, 12, 54,
			197, 185, 23, 154, 73, 140, 47, 213, // Header.StakeRoot chainhash.Hash (32bytes)
			43, 168, 53, 107, 36, 100, 196, 117,
			137, 206, 130, 246, 181, 40, 95, 85,
			106, 164, 9, 187, 149, 251, 148, 162,
			1, 0, // Header.VoteBits uint16
			169, 68, 44, 238, 119, 144, // Header.FinalState [6]byte
			3, 0, // Header.Voters uint16
			0,             // Header.FreshStake uint8
			0,             // Header.Revocations uint8
			210, 16, 0, 0, // Header.PoolSize uint32
			255, 255, 63, 32, // Header.Bits uint32
			199, 241, 172, 116, 4, 0, 0, 0, // Header.SBits int64
			250, 27, 1, 0, // Header.Height uint32
			180, 5, 0, 0, // Header.Size uint32
			92, 178, 15, 92, // Header.Timestamp time.Time
			66, 212, 230, 104, // Header.Nonce uint32
			124, 1, 0, 0, 0, 0, 0, 0, // Header.ExtraData [32]byte
			178, 225, 91, 116, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			6, 0, 0, 0, // Header.StakeVersion uint32
		},
		[]byte{5, 2, 51, 213, 131, 252, 145, 16, 37, 182, 217, 191, 224, 115, 168, 188, 135, 140, 96, 37, 60, 8, 49, 234, 41, 22, 36, 126, 226, 212, 173, 69, 227, 79, 95, 196, 34, 245, 239, 15, 60, 134, 13, 207, 75, 187, 105, 232, 200, 49, 50, 46, 53, 244, 86, 63, 99, 47, 87, 52, 7, 245, 102, 249, 80, 87, 103, 96, 31, 150, 147, 171, 237, 65, 41, 52, 93, 181, 126, 48, 222, 17, 209, 37, 212, 92, 207, 36, 103, 84, 35, 78, 129, 121, 165, 45, 255, 5, 195, 17},
		binary.LittleEndian.Uint32([]byte{66, 212, 230, 104}),
		1,
	},
	{
		true, []byte{6, 0, 0, 0, 83, 197, 12, 104, 128, 74, 31, 177, 75, 135, 3, 76, 27, 118, 146, 63, 114, 247, 216, 231, 180, 24, 251, 45, 20, 179, 157, 11, 12, 177, 232, 1, 38, 123, 9, 90, 177, 221, 88, 141, 48, 80, 189, 80, 55, 15, 6, 30, 38, 87, 134, 195, 252, 84, 216, 19, 174, 103, 166, 203, 61, 207, 200, 182, 182, 136, 71, 132, 86, 65, 211, 185, 246, 178, 152, 254, 55, 176, 211, 26, 228, 192, 92, 79, 209, 3, 54, 208, 173, 127, 204, 153, 61, 139, 25, 22, 1, 0, 68, 78, 120, 163, 129, 161, 4, 0, 0, 0, 165, 16, 0, 0, 255, 255, 63, 32, 199, 241, 172, 116, 4, 0, 0, 0, 3, 28, 1, 0, 10, 7, 0, 0, 99, 181, 15, 92, 84, 203, 149, 108, 16, 3, 0, 0, 0, 0, 0, 0, 178, 225, 91, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0},
		[]byte{1, 27, 18, 25, 93, 244, 75, 218, 27, 181, 126, 60, 161, 17, 105, 241, 248, 205, 132, 234, 9, 20, 224, 165, 123, 17, 237, 217, 78, 238, 115, 138, 248, 138, 190, 248, 131, 138, 137, 128, 245, 215, 182, 22, 239, 99, 19, 236, 10, 225, 26, 158, 158, 223, 204, 241, 95, 55, 114, 117, 218, 209, 131, 124, 113, 205, 48, 179, 208, 236, 104, 255, 211, 195, 46, 32, 16, 109, 147, 28, 114, 212, 243, 85, 58, 182, 159, 169, 74, 20, 254, 83, 126, 154, 193, 162, 109, 125, 40, 38},
		binary.LittleEndian.Uint32([]byte{84, 203, 149, 108}),
		1,
	}, {
		true, []byte{6, 0, 0, 0, 139, 189, 103, 97, 145, 91, 247, 198, 168, 61, 65, 59, 27, 32, 1, 101, 86, 111, 45, 206, 205, 50, 8, 118, 118, 190, 21, 28, 44, 43, 49, 6, 243, 149, 47, 22, 45, 140, 98, 51, 223, 18, 171, 106, 33, 121, 85, 238, 122, 54, 207, 127, 222, 45, 117, 102, 35, 242, 235, 80, 249, 188, 219, 123, 63, 131, 203, 120, 238, 63, 175, 80, 191, 41, 83, 22, 197, 97, 93, 236, 165, 228, 130, 157, 197, 219, 153, 210, 37, 235, 152, 83, 33, 162, 149, 149, 1, 0, 172, 73, 121, 180, 50, 117, 3, 0, 0, 0, 170, 16, 0, 0, 255, 255, 63, 32, 199, 241, 172, 116, 4, 0, 0, 0, 2, 28, 1, 0, 177, 5, 0, 0, 47, 181, 15, 92, 66, 163, 239, 140, 251, 2, 0, 0, 0, 0, 0, 0, 178, 225, 91, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0},
		[]byte{3, 14, 198, 255, 69, 103, 108, 117, 61, 58, 228, 121, 162, 38, 177, 39, 84, 86, 9, 235, 20, 33, 29, 124, 161, 18, 121, 98, 40, 159, 244, 106, 123, 181, 253, 22, 189, 166, 197, 18, 44, 115, 122, 63, 0, 255, 15, 255, 106, 169, 5, 149, 94, 102, 183, 149, 8, 6, 36, 239, 189, 52, 225, 54, 77, 22, 234, 78, 213, 254, 25, 131, 239, 3, 140, 10, 87, 117, 171, 33, 90, 6, 14, 209, 233, 129, 252, 86, 148, 223, 94, 12, 4, 246, 142, 16, 191, 107, 11, 30},
		binary.LittleEndian.Uint32([]byte{66, 163, 239, 140}),
		1,
	}, {
		true, []byte{6, 0, 0, 0, 77, 210, 55, 151, 123, 235, 101, 93, 38, 241, 82, 161, 219, 158, 1, 94, 230, 19, 72, 175, 86, 205, 188, 60, 215, 255, 101, 66, 122, 192, 224, 45, 97, 213, 205, 218, 7, 60, 140, 57, 45, 212, 215, 109, 209, 164, 14, 133, 220, 192, 174, 227, 187, 71, 21, 4, 11, 86, 142, 208, 124, 202, 115, 152, 37, 31, 180, 80, 51, 114, 226, 5, 117, 141, 76, 37, 29, 55, 23, 209, 229, 112, 170, 161, 244, 201, 80, 95, 50, 94, 207, 136, 51, 137, 60, 131, 1, 0, 74, 49, 113, 237, 118, 52, 3, 0, 0, 0, 175, 16, 0, 0, 255, 255, 63, 32, 199, 241, 172, 116, 4, 0, 0, 0, 1, 28, 1, 0, 178, 5, 0, 0, 168, 180, 15, 92, 128, 45, 74, 218, 176, 2, 0, 0, 0, 0, 0, 0, 178, 225, 91, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0},
		[]byte{7, 207, 216, 66, 250, 150, 77, 177, 26, 246, 147, 236, 242, 137, 72, 78, 13, 27, 193, 203, 94, 249, 93, 243, 135, 8, 65, 121, 247, 38, 219, 66, 109, 7, 27, 23, 120, 226, 41, 231, 169, 184, 197, 26, 144, 84, 159, 144, 62, 247, 23, 129, 216, 145, 4, 93, 78, 183, 6, 215, 2, 152, 100, 111, 206, 162, 233, 161, 37, 39, 217, 191, 148, 211, 60, 23, 226, 62, 238, 217, 207, 82, 254, 252, 16, 109, 24, 130, 130, 60, 189, 15, 157, 165, 165, 87, 173, 199, 240, 154},
		binary.LittleEndian.Uint32([]byte{128, 45, 74, 218}),
		1,
	}, {
		true, []byte{6, 0, 0, 0, 94, 66, 66, 66, 68, 57, 248, 15, 6, 250, 138, 201, 234, 216, 119, 162, 163, 122, 101, 185, 43, 121, 169, 123, 66, 161, 99, 215, 67, 29, 92, 15, 147, 122, 253, 85, 159, 49, 242, 140, 26, 230, 224, 86, 173, 6, 158, 53, 223, 46, 213, 105, 137, 157, 115, 185, 86, 204, 101, 84, 21, 237, 15, 157, 225, 250, 251, 211, 124, 74, 219, 184, 102, 132, 22, 238, 140, 31, 31, 238, 242, 95, 123, 235, 63, 152, 206, 245, 228, 73, 138, 29, 93, 15, 56, 195, 1, 0, 222, 162, 118, 160, 226, 228, 4, 0, 0, 0, 180, 16, 0, 0, 255, 255, 63, 32, 199, 241, 172, 116, 4, 0, 0, 0, 0, 28, 1, 0, 10, 7, 0, 0, 7, 180, 15, 92, 239, 64, 104, 116, 97, 2, 0, 0, 0, 0, 0, 0, 178, 225, 91, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0},
		[]byte{7, 169, 150, 150, 185, 54, 95, 151, 51, 88, 211, 158, 196, 109, 8, 39, 100, 40, 193, 173, 70, 136, 231, 93, 179, 19, 183, 185, 245, 24, 247, 142, 73, 233, 93, 30, 35, 81, 249, 143, 166, 42, 84, 5, 231, 210, 181, 189, 104, 213, 13, 43, 151, 37, 53, 128, 203, 57, 180, 119, 173, 102, 50, 150, 202, 231, 66, 236, 225, 121, 212, 131, 149, 84, 12, 25, 37, 133, 31, 252, 0, 237, 82, 190, 63, 233, 100, 118, 203, 202, 174, 211, 59, 13, 189, 49, 12, 243, 125, 29},
		binary.LittleEndian.Uint32([]byte{239, 64, 104, 116}),
		1,
	}, {
		true, []byte{6, 0, 0, 0, 26, 39, 211, 139, 195, 59, 146, 204, 25, 120, 197, 105, 205, 252, 11, 36, 193, 185, 243, 136, 203, 247, 169, 91, 11, 244, 24, 145, 58, 230, 95, 51, 172, 154, 60, 169, 168, 161, 88, 146, 106, 138, 86, 49, 199, 129, 193, 183, 43, 248, 224, 179, 154, 37, 227, 193, 254, 248, 6, 161, 54, 14, 32, 52, 88, 108, 112, 132, 155, 3, 14, 66, 78, 41, 108, 99, 154, 92, 151, 211, 75, 66, 95, 188, 47, 110, 88, 11, 150, 153, 105, 118, 179, 147, 101, 92, 1, 0, 81, 65, 194, 22, 38, 138, 4, 0, 0, 0, 185, 16, 0, 0, 255, 255, 63, 32, 199, 241, 172, 116, 4, 0, 0, 0, 255, 27, 1, 0, 11, 7, 0, 0, 243, 179, 15, 92, 172, 20, 45, 118, 85, 2, 0, 0, 0, 0, 0, 0, 178, 225, 91, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0},
		[]byte{4, 121, 161, 111, 155, 67, 130, 65, 36, 100, 23, 249, 101, 101, 103, 118, 237, 128, 213, 228, 75, 213, 121, 129, 124, 13, 56, 241, 214, 126, 108, 78, 2, 250, 148, 27, 62, 1, 148, 127, 193, 181, 189, 93, 199, 35, 33, 8, 84, 211, 6, 178, 243, 30, 151, 100, 151, 38, 58, 181, 36, 165, 243, 22, 36, 55, 165, 158, 165, 4, 211, 205, 24, 101, 117, 10, 174, 167, 181, 195, 77, 9, 176, 150, 104, 18, 217, 228, 79, 206, 52, 93, 194, 213, 115, 30, 121, 147, 168, 224},
		binary.LittleEndian.Uint32([]byte{172, 20, 45, 118}),
		1,
	}, {
		true, []byte{6, 0, 0, 0, 96, 79, 54, 137, 143, 211, 38, 130, 247, 201, 160, 30, 239, 41, 53, 20, 0, 154, 116, 231, 39, 80, 115, 153, 195, 163, 69, 71, 139, 55, 20, 29, 234, 192, 178, 173, 39, 108, 180, 177, 191, 183, 16, 84, 16, 18, 230, 245, 158, 143, 127, 214, 140, 41, 100, 49, 20, 115, 199, 2, 120, 251, 174, 117, 38, 225, 218, 45, 91, 192, 221, 218, 26, 29, 67, 41, 101, 77, 178, 177, 131, 113, 221, 53, 84, 96, 56, 94, 247, 131, 250, 189, 4, 15, 245, 103, 1, 0, 83, 55, 246, 39, 183, 111, 3, 0, 0, 0, 190, 16, 0, 0, 255, 255, 63, 32, 199, 241, 172, 116, 4, 0, 0, 0, 254, 27, 1, 0, 180, 5, 0, 0, 214, 179, 15, 92, 43, 49, 157, 243, 72, 2, 0, 0, 0, 0, 0, 0, 178, 225, 91, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0},
		[]byte{3, 76, 125, 68, 204, 61, 96, 241, 113, 153, 237, 94, 144, 218, 10, 141, 159, 146, 88, 63, 5, 216, 61, 70, 136, 17, 158, 149, 46, 159, 3, 25, 239, 93, 16, 222, 191, 183, 89, 203, 63, 18, 186, 58, 191, 103, 147, 146, 131, 50, 4, 76, 112, 203, 187, 36, 7, 54, 67, 93, 140, 184, 195, 56, 216, 207, 179, 187, 157, 109, 116, 41, 246, 81, 226, 7, 137, 180, 232, 171, 29, 212, 64, 0, 27, 194, 228, 226, 138, 195, 157, 238, 137, 251, 98, 143, 219, 235, 111, 212},
		binary.LittleEndian.Uint32([]byte{43, 49, 157, 243}),
		1,
	}, {
		true, []byte{6, 0, 0, 0, 49, 110, 251, 181, 47, 169, 105, 204, 249, 211, 149, 135, 137, 244, 120, 83, 33, 103, 36, 214, 109, 110, 190, 0, 50, 111, 88, 183, 237, 155, 45, 11, 53, 46, 31, 127, 44, 193, 186, 108, 116, 58, 179, 97, 182, 213, 65, 59, 237, 29, 162, 180, 202, 19, 149, 189, 126, 187, 198, 156, 62, 71, 147, 29, 180, 193, 248, 44, 18, 25, 139, 36, 39, 165, 224, 105, 162, 138, 156, 181, 106, 98, 123, 71, 198, 172, 162, 167, 173, 7, 111, 158, 120, 213, 225, 61, 1, 0, 99, 66, 78, 120, 90, 192, 3, 0, 0, 0, 195, 16, 0, 0, 255, 255, 63, 32, 199, 241, 172, 116, 4, 0, 0, 0, 253, 27, 1, 0, 179, 5, 0, 0, 145, 179, 15, 92, 50, 244, 195, 184, 36, 2, 0, 0, 0, 0, 0, 0, 178, 225, 91, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0},
		[]byte{18, 102, 245, 9, 177, 223, 149, 19, 189, 61, 247, 197, 137, 176, 223, 77, 181, 118, 87, 145, 255, 223, 230, 217, 73, 44, 253, 168, 196, 204, 106, 24, 245, 9, 27, 186, 16, 165, 56, 74, 7, 105, 59, 193, 88, 143, 150, 243, 239, 92, 29, 67, 5, 255, 200, 53, 27, 1, 38, 93, 104, 127, 102, 232, 16, 123, 211, 129, 213, 255, 86, 135, 253, 61, 97, 41, 76, 22, 167, 114, 172, 97, 24, 220, 25, 242, 121, 132, 99, 208, 37, 148, 52, 199, 6, 68, 55, 160, 185, 117},
		binary.LittleEndian.Uint32([]byte{50, 244, 195, 184}),
		1,
	}, {
		true, []byte{6, 0, 0, 0, 80, 173, 173, 173, 79, 108, 87, 195, 42, 41, 9, 208, 139, 8, 136, 233, 33, 23, 248, 98, 173, 240, 226, 176, 253, 66, 201, 137, 137, 87, 101, 3, 132, 78, 27, 44, 121, 211, 184, 193, 4, 182, 69, 203, 249, 164, 29, 226, 113, 198, 75, 34, 67, 98, 95, 165, 156, 122, 212, 217, 227, 55, 219, 224, 70, 33, 221, 123, 213, 64, 107, 73, 97, 24, 109, 213, 42, 173, 14, 156, 184, 130, 222, 130, 10, 254, 194, 77, 84, 254, 126, 73, 216, 198, 247, 63, 1, 0, 127, 188, 57, 132, 78, 227, 3, 0, 0, 0, 200, 16, 0, 0, 255, 255, 63, 32, 199, 241, 172, 116, 4, 0, 0, 0, 252, 27, 1, 0, 178, 5, 0, 0, 86, 179, 15, 92, 66, 27, 215, 44, 6, 2, 0, 0, 0, 0, 0, 0, 178, 225, 91, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0},
		[]byte{1, 98, 164, 202, 149, 58, 138, 115, 222, 6, 114, 160, 34, 12, 128, 252, 6, 36, 212, 248, 142, 248, 252, 252, 160, 1, 115, 77, 130, 4, 70, 42, 45, 198, 248, 213, 96, 112, 253, 206, 61, 12, 127, 212, 202, 7, 248, 238, 161, 156, 25, 63, 55, 210, 247, 156, 6, 237, 167, 4, 105, 65, 18, 194, 225, 83, 40, 17, 201, 232, 63, 67, 101, 53, 140, 26, 93, 206, 31, 64, 129, 12, 168, 214, 91, 118, 215, 68, 196, 3, 252, 40, 104, 42, 54, 11, 31, 242, 143, 84},
		binary.LittleEndian.Uint32([]byte{66, 27, 215, 44}),
		1,
	}, {
		true, []byte{6, 0, 0, 0, 35, 149, 247, 25, 167, 148, 37, 222, 208, 21, 250, 207, 152, 173, 140, 235, 41, 131, 233, 200, 113, 198, 198, 128, 93, 208, 192, 92, 40, 151, 92, 2, 120, 184, 117, 123, 106, 12, 73, 57, 62, 36, 132, 90, 35, 80, 110, 159, 227, 154, 97, 171, 63, 204, 143, 223, 89, 234, 180, 1, 86, 59, 9, 91, 207, 167, 188, 151, 83, 10, 171, 171, 0, 187, 135, 87, 42, 171, 150, 158, 230, 46, 2, 27, 194, 10, 136, 90, 184, 136, 232, 150, 246, 103, 110, 24, 1, 0, 216, 114, 81, 88, 11, 4, 3, 0, 0, 0, 205, 16, 0, 0, 255, 255, 63, 32, 199, 241, 172, 116, 4, 0, 0, 0, 251, 27, 1, 0, 178, 5, 0, 0, 1, 179, 15, 92, 45, 51, 52, 78, 217, 1, 0, 0, 0, 0, 0, 0, 178, 225, 91, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0},
		[]byte{3, 93, 170, 168, 50, 76, 215, 114, 34, 84, 7, 124, 66, 1, 172, 86, 165, 115, 61, 86, 198, 143, 31, 16, 95, 45, 76, 207, 115, 119, 44, 210, 198, 32, 150, 107, 48, 198, 177, 82, 109, 21, 55, 154, 6, 124, 141, 172, 69, 41, 26, 227, 248, 86, 50, 234, 19, 38, 84, 121, 215, 77, 183, 44, 247, 79, 240, 34, 106, 171, 155, 243, 102, 113, 35, 37, 199, 255, 227, 146, 103, 168, 19, 178, 60, 137, 156, 18, 185, 96, 25, 233, 55, 232, 213, 122, 229, 63, 208, 91},
		binary.LittleEndian.Uint32([]byte{45, 51, 52, 78}),
		1,
	},
	// Negative cases

	// Single (third) byte is changed
	{
		false, []byte{6, 0, 1, 0, 248, 93, 233, 12, 17, 212, 94, 177, 53, 152, 220, 165, 143, 204, 86, 16, 181, 70, 109, 99, 248, 26, 218, 254, 114, 153, 31, 82, 76, 1, 83, 12, 38, 95, 7, 145, 250, 44, 210, 131, 159, 43, 224, 21, 21, 114, 217, 232, 46, 246, 46, 100, 115, 7, 121, 121, 72, 141, 39, 148, 161, 50, 12, 54, 197, 185, 23, 154, 73, 140, 47, 213, 43, 168, 53, 107, 36, 100, 196, 117, 137, 206, 130, 246, 181, 40, 95, 85, 106, 164, 9, 187, 149, 251, 148, 162, 1, 0, 169, 68, 44, 238, 119, 144, 3, 0, 0, 0, 210, 16, 0, 0, 255, 255, 63, 32, 199, 241, 172, 116, 4, 0, 0, 0, 250, 27, 1, 0, 180, 5, 0, 0, 92, 178, 15, 92, 66, 212, 230, 104, 124, 1, 0, 0, 0, 0, 0, 0, 178, 225, 91, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0},
		[]byte{5, 2, 51, 213, 131, 252, 145, 16, 37, 182, 217, 191, 224, 115, 168, 188, 135, 140, 96, 37, 60, 8, 49, 234, 41, 22, 36, 126, 226, 212, 173, 69, 227, 79, 95, 196, 34, 245, 239, 15, 60, 134, 13, 207, 75, 187, 105, 232, 200, 49, 50, 46, 53, 244, 86, 63, 99, 47, 87, 52, 7, 245, 102, 249, 80, 87, 103, 96, 31, 150, 147, 171, 237, 65, 41, 52, 93, 181, 126, 48, 222, 17, 209, 37, 212, 92, 207, 36, 103, 84, 35, 78, 129, 121, 165, 45, 255, 5, 195, 17},
		binary.LittleEndian.Uint32([]byte{66, 212, 230, 104}),
		1,
	},
	// Two bytes swapped
	{
		false, []byte{6, 0, 0, 0, 93, 248, 233, 12, 17, 212, 94, 177, 53, 152, 220, 165, 143, 204, 86, 16, 181, 70, 109, 99, 248, 26, 218, 254, 114, 153, 31, 82, 76, 1, 83, 12, 38, 95, 7, 145, 250, 44, 210, 131, 159, 43, 224, 21, 21, 114, 217, 232, 46, 246, 46, 100, 115, 7, 121, 121, 72, 141, 39, 148, 161, 50, 12, 54, 197, 185, 23, 154, 73, 140, 47, 213, 43, 168, 53, 107, 36, 100, 196, 117, 137, 206, 130, 246, 181, 40, 95, 85, 106, 164, 9, 187, 149, 251, 148, 162, 1, 0, 169, 68, 44, 238, 119, 144, 3, 0, 0, 0, 210, 16, 0, 0, 255, 255, 63, 32, 199, 241, 172, 116, 4, 0, 0, 0, 250, 27, 1, 0, 180, 5, 0, 0, 92, 178, 15, 92, 66, 212, 230, 104, 124, 1, 0, 0, 0, 0, 0, 0, 178, 225, 91, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0},
		[]byte{5, 2, 51, 213, 131, 252, 145, 16, 37, 182, 217, 191, 224, 115, 168, 188, 135, 140, 96, 37, 60, 8, 49, 234, 41, 22, 36, 126, 226, 212, 173, 69, 227, 79, 95, 196, 34, 245, 239, 15, 60, 134, 13, 207, 75, 187, 105, 232, 200, 49, 50, 46, 53, 244, 86, 63, 99, 47, 87, 52, 7, 245, 102, 249, 80, 87, 103, 96, 31, 150, 147, 171, 237, 65, 41, 52, 93, 181, 126, 48, 222, 17, 209, 37, 212, 92, 207, 36, 103, 84, 35, 78, 129, 121, 165, 45, 255, 5, 195, 17},
		binary.LittleEndian.Uint32([]byte{66, 212, 230, 104}),
		1,
	},
}

func testSingle1445Validation(t *testing.T, test equihash1445TestCase) {
	var input []byte
	if test.algoVersion == 0 {
		input = AppendExpandedNonce(test.header, test.nonce)
	} else {
		input = test.header
	}

	result := ValidateEquihash(144, 5, input, test.solution)

	if result != test.valid {
		t.Fatalf("Validation result does not match: want %v, got %v", test.valid, result)
	}
}

func testSingleSolution(t *testing.T, test solverTest) {
	data := SolutionAppenderData{
		n:        test.n,
		k:        test.k,
		solution: &SolutionHolder{},
	}

	SolveEquihash(test.n, test.k, test.I, test.nonce, test.algoVersion, data)

	if len(data.solution.fullSolution) != len(test.solutions) {
		t.Fatalf("Solution size mismatch. got %d, want %d", len(data.solution.fullSolution), len(test.solutions))
	}

	for i := 0; i < len(test.solutions); i++ {
		if len(data.solution.fullSolution[i]) != len(test.solutions[i]) {
			t.Fatalf("Solution row size mismatch. got %d, want %d", len(data.solution.fullSolution[i]), len(test.solutions[i]))
		}

		for j := 0; j < len(test.solutions[i]); j++ {
			if data.solution.fullSolution[i][j] != test.solutions[i][j] {
				t.Fatalf("Solution content mismatch. got %d, want %d at {%d, %d}",
					data.solution.fullSolution[i][j], test.solutions[i][j], i, j)
			}
		}

		var input []byte
		if test.algoVersion == 0 {
			input = AppendExpandedNonce(test.I, test.nonce)
		} else {
			input = test.I
		}

		compressedSolution := compressIndices(test.n, test.k, test.nonce, test.I, data.solution.fullSolution[i])
		result := ValidateEquihash(test.n, test.k, input, compressedSolution)

		if !result {
			t.Logf("Validation result: %v", result)
		}
	}
}

func testSingleValidation(t *testing.T, test validatorTest) {

	var input []byte
	if test.algoVersion == 0 {
		input = AppendExpandedNonce(test.I, test.nonce)
	} else {
		input = test.I
	}

	solution := compressIndices(test.n, test.k, test.nonce, test.I, test.solution)
	result := ValidateEquihash(test.n, test.k, input, solution)

	if result != test.valid {
		t.Fatalf("Validation result does not match: want %v, got %v", test.valid, result)
	}
}

func TestSolveEquihash(t *testing.T) {
	for _, test := range solverTests {
		testSingleSolution(t, test)
	}
}

func TestValidateEquihash(t *testing.T) {
	for _, test := range validatorTests {
		testSingleValidation(t, test)
	}
}

func TestValidate1445Equihash(t *testing.T) {
	for _, test := range equihash1445TestCases {
		testSingle1445Validation(t, test)
	}
}

func TestValidate1445EquihashBitByBit(t *testing.T) {
	for _, test := range equihash1445TestCases {
		// Filter out invalid solution test cases
		if !test.valid {
			continue
		}

		const bits = 8
		for i := 0; i < len(test.header)*bits; i++ {
			// Modify input bit by bit and ensure it became invalid
			input := make([]byte, len(test.header))
			copy(input, test.header)
			input[i/bits] ^= 1 << uint(i%bits)

			isValid := ValidateEquihash(144, 5, input, test.solution)
			if isValid {
				t.Fatalf("Equihash solution should become invalid after modification of %v byte at %v bit", i/bits, i%bits)
			}
		}

	}
}
